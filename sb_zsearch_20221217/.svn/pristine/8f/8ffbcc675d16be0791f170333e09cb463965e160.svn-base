package com.vo.repository;

import java.security.KeyStore.PrivateKeyEntry;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;
import java.util.stream.Collectors;

import javax.transaction.Transactional;

import org.hibernate.action.internal.CollectionUpdateAction;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import com.fasterxml.jackson.databind.jsontype.impl.AsExistingPropertyTypeSerializer;
import com.google.common.collect.Lists;
import com.vo.Load;
import com.vo.entity.CiEntity;
import com.vo.fenci.Fenci;
import com.votool.ze.AbstractZETask;
import com.votool.ze.ZE;
import com.votool.ze.ZES;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.util.StrUtil;
import javafx.scene.control.Tab;

/**
 *
 *
 * @author zhangzhen
 * @date 2022年12月17日
 *
 */
@Repository
public class CiRepository {

	private final ZE ze = ZES.newZE(100);

	@Autowired
	private Load load;
	@Autowired
	private JdbcTemplate jdbcTemplate;

	public List<CiEntity> search(final String k, final int limit) {

//		if (this.load.contains(k)) {
//			final String k2 = StrUtil.isEmpty(k) ? "" : k;
//			final String sql = "SELECT * FROM ci WHERE ci @> array['" + k2 + "'::varchar(256)] "
//					+ "or ci @> array['" + k2.toUpperCase() + "'::varchar(256)] "
//					+ "or ci @> array['" + k2.toLowerCase() + "'::varchar(256)] limit " + limit;
////			System.out.println("search-sql = " + sql);
//			final List<CiEntity> list = this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(CiEntity.class));
//			return list;
//		}

		final List<String> ciList = Fenci.fenci(k);
//		final StringJoiner where = new StringJoiner("or", "(", ")");

//		final List<String> sqlList = Lists.newArrayList();

		final List<AbstractZETask<List<CiEntity>>> taskList = Lists.newArrayList();

		ciList.sort(Comparator.comparing(String::length).reversed());

		final String select = "SELECT * FROM ci WHERE ";
		for (final String ci : ciList) {

			if (ci.length() <= 1) {
				continue;
			}

			final String ci2 = StrUtil.isEmpty(ci) ? "" : ci;
			final String sql = select + "ci @> array['" + ci2.toLowerCase() + "'::varchar(256)] " + " limit " + limit;

			final AbstractZETask<List<CiEntity>> task =new AbstractZETask<List<CiEntity>>() {

				@Override
				public List<CiEntity> call() {
					System.out.println(java.time.LocalDateTime.now() + "\t" + Thread.currentThread().getName() + "\t"
							+ "CiRepository.search-k = " + ci2);

					return CiRepository.this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(CiEntity.class));
				}
			};

			taskList.add(task);
		}

		final List<List<CiEntity>> r = this.ze.submitInQueueAndGet(taskList);
		if (CollUtil.isNotEmpty(r)) {
			final List<CiEntity> rr = r.stream().flatMap(l -> l.stream()).collect(Collectors.toList());
			return rr;
		}

		final List<AbstractZETask<List<CiEntity>>> taskList2 = Lists.newArrayList();
		for (final String ci : ciList) {

			if (ci.length() > 1) {
				continue;
			}

			final String ci2 = StrUtil.isEmpty(ci) ? "" : ci;
			final String sql = select + "ci @> array['" + ci2.toLowerCase() + "'::varchar(256)] " + " limit " + limit;

			final AbstractZETask<List<CiEntity>> task =new AbstractZETask<List<CiEntity>>() {

				@Override
				public List<CiEntity> call() {
					System.out.println(java.time.LocalDateTime.now() + "\t" + Thread.currentThread().getName() + "\t"
							+ "CiRepository.search-k = " + ci2);

					return CiRepository.this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(CiEntity.class));
				}
			};

			taskList2.add(task);
		}
		final List<List<CiEntity>> r2 = this.ze.submitInQueueAndGet(taskList2);
		final List<CiEntity> rr2 = r2.stream().flatMap(l -> l.stream()).collect(Collectors.toList());
		return rr2;


//		final String select = "SELECT * FROM ci WHERE ";
//		final String sql = select + where + " limit " + limit;
//		final List<CiEntity> list = this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(CiEntity.class));
//		return list;



//		final List<String> ciList = Fenci.fenci(k);
//		final StringJoiner where = new StringJoiner("or", "(", ")");
//		for (final String ci : ciList) {
//			final String ci2 = StrUtil.isEmpty(ci) ? "" : ci;
//			where.add(" ci @> array['" + ci2.toLowerCase() + "'::varchar(256)] ");
//		}
//
//		final String select = "SELECT * FROM ci WHERE ";
//		final String sql = select + where + " limit " + limit;
//		final List<CiEntity> list = this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(CiEntity.class));
//		return list;
	}

	public Long countByMaxIdAndMinId() {
		final String count = "select (max(id) - min(id)) as count from ci;";
//		final String count = "select count(id) as count from ci;";

		final List<Map<String, Object>> list = this.jdbcTemplate.queryForList(count);
		final Map<String, Object> m = list.get(0);
		final Object object = m.get("count");
		return Long.valueOf(String.valueOf(object));
	}


	public List<CiEntity> findByIdLimit(final Long id, final int limit) {

		final String sql = "select id, ci from ci where id >  " + id + " order by id asc limit " + limit;

		final List<CiEntity> list = this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(CiEntity.class));

		return list;

	}

	public List<CiEntity> findCiPage(final int pageNo ,final int pageSize) {

		final int limit = pageSize;
		final int offset = (pageNo - 1) * pageSize;
		final String sql = "select id,ci from ci limit " + limit + " offset " + offset;
//		System.out.println("fincIpage-sql = " + sql);

		final List<CiEntity> list = this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(CiEntity.class));

		return list;
	}


	public List<CiEntity> findAll() {

		final String sql = "select * from ci";
		final List<CiEntity> list = this.jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(CiEntity.class));

		return list;
	}


	@Transactional(rollbackOn = Exception.class)
	public void add(final String content) {

		final List<String> ciList = Fenci.fenci(content);

//		Collections.shuffle(ciList);

//		System.out.println("ciList = " + ciList);
		final String a = Fenci.toPgsqlArray(ciList);
//		System.out.println("a = " + a);

//	insert into ci(ci,content) values ('{" ","成","成功","了","K","ok","OK","O","功"}','OK 成功了');
//		final String sql = "insert into ci(ci,content) values ('" + a.toLowerCase() + "','" + content + "');";
		final String sql = "insert into ci(ci,content) values ('%s','%s');";

		final String format = String.format(sql, a.toLowerCase(),content);

//		System.out.println("add-sql = " + format);

		this.jdbcTemplate.execute(format);

	}

}
